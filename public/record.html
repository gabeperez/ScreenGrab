<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Record - ScreenGrab</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <header>
    <div class="header-content">
      <a href="/" class="logo">üé• ScreenGrab</a>
      <nav class="nav-links">
        <a href="/dashboard.html">Dashboard</a>
        <button onclick="logout()" class="btn btn-secondary">Logout</button>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <div class="recording-container">
      <h1 class="mb-3">Record Your Screen</h1>
      
      <div id="setup-section">
        <div class="card">
          <div class="form-group">
            <label class="form-label">Video expiration</label>
            <select id="expiration-select" class="form-select">
              <option value="24h">24 Hours</option>
              <option value="1week" selected>1 Week</option>
              <option value="1month">1 Month</option>
            </select>
          </div>
          
          <button onclick="startRecording()" class="btn btn-large" style="width: 100%;">
            üé¨ Start Recording
          </button>
          
          <p class="mt-3 text-center" style="color: var(--text-secondary); font-size: 14px;">
            You'll be prompted to choose which screen, window, or tab to record.
          </p>
        </div>
      </div>

      <div id="recording-section" class="hidden">
        <div class="preview-container">
          <video id="preview-video" class="preview-video" autoplay muted></video>
          <div id="recording-indicator" class="recording-indicator hidden">
            <div class="recording-dot"></div>
            <span class="recording-timer">0:00</span>
          </div>
        </div>

        <div class="controls">
          <button id="record-btn" onclick="toggleRecording()" class="btn btn-large btn-danger">
            ‚è∫ Start Recording
          </button>
          <button id="stop-btn" onclick="stopRecording()" class="btn btn-large" disabled>
            ‚èπ Stop Recording
          </button>
          <button onclick="cancelRecording()" class="btn btn-large btn-secondary">
            ‚úï Cancel
          </button>
        </div>
      </div>

      <div id="uploading-section" class="hidden">
        <div class="card text-center">
          <div class="spinner"></div>
          <h3 class="mt-3">Uploading your video...</h3>
          <p style="color: var(--text-secondary);">This may take a moment depending on the video size.</p>
          <div id="upload-progress" class="mt-2"></div>
        </div>
      </div>

      <div id="success-section" class="hidden">
        <div class="card text-center">
          <div style="font-size: 64px; margin-bottom: 16px;">‚úÖ</div>
          <h2 class="mb-2">Video Ready!</h2>
          <p class="mb-3" style="color: var(--text-secondary);">Your video has been uploaded and is ready to share.</p>
          
          <div class="form-group">
            <input type="text" id="share-link" class="form-input" readonly>
          </div>
          
          <div class="controls">
            <button onclick="copyLink()" class="btn">
              üìã Copy Link
            </button>
            <button onclick="openVideo()" class="btn btn-secondary">
              üëÅÔ∏è View Video
            </button>
            <button onclick="downloadVideo()" class="btn btn-secondary">
              üì• Download
            </button>
          </div>
          
          <button onclick="recordAnother()" class="btn btn-large mt-4" style="width: 100%;">
            üé¨ Record Another
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="/utils.js"></script>
  <script>
    let mediaRecorder;
    let recordedChunks = [];
    let stream;
    let recordingStartTime;
    let timerInterval;
    let currentVideoId;
    let currentExpirationType;

    async function init() {
      // Handle token from OAuth callback
      handleAuthToken();
      
      const user = await requireAuth();
      if (!user) return;
    }

    async function startRecording() {
      try {
        // Get screen capture
        stream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            mediaSource: 'screen',
            cursor: 'always',
          },
          audio: true,
        });

        // Show preview
        const preview = document.getElementById('preview-video');
        preview.srcObject = stream;

        // Show recording section
        document.getElementById('setup-section').classList.add('hidden');
        document.getElementById('recording-section').classList.remove('hidden');

        // Get expiration type
        currentExpirationType = document.getElementById('expiration-select').value;

        // Enable record button
        document.getElementById('record-btn').disabled = false;

      } catch (error) {
        console.error('Error starting screen capture:', error);
        showToast('Failed to start screen capture. Please try again.', 'error');
      }
    }

    function toggleRecording() {
      if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        startActualRecording();
      }
    }

    function startActualRecording() {
      recordedChunks = [];
      
      const options = {
        mimeType: 'video/webm;codecs=vp9',
        videoBitsPerSecond: 2500000,
      };

      try {
        mediaRecorder = new MediaRecorder(stream, options);
      } catch (e) {
        // Fallback to default codec
        mediaRecorder = new MediaRecorder(stream);
      }

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = handleRecordingComplete;

      mediaRecorder.start(100); // Collect data every 100ms

      // Update UI
      document.getElementById('record-btn').disabled = true;
      document.getElementById('stop-btn').disabled = false;
      document.getElementById('recording-indicator').classList.remove('hidden');

      // Start timer
      recordingStartTime = Date.now();
      updateTimer();
      timerInterval = setInterval(updateTimer, 1000);
    }

    function updateTimer() {
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      document.querySelector('.recording-timer').textContent = 
        `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        clearInterval(timerInterval);
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
      }
    }

    function cancelRecording() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      if (timerInterval) {
        clearInterval(timerInterval);
      }
      
      document.getElementById('recording-section').classList.add('hidden');
      document.getElementById('setup-section').classList.remove('hidden');
      
      recordedChunks = [];
    }

    async function handleRecordingComplete() {
      // Hide recording section, show uploading
      document.getElementById('recording-section').classList.add('hidden');
      document.getElementById('uploading-section').classList.remove('hidden');

      try {
        // Create blob from recorded chunks
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const filename = `recording-${Date.now()}.webm`;
        const duration = Math.floor((Date.now() - recordingStartTime) / 1000);

        // Prepare upload
        const prepareResponse = await apiCall('/api/videos/prepare-upload', {
          method: 'POST',
          body: JSON.stringify({
            filename,
            expirationType: currentExpirationType,
          }),
        });

        currentVideoId = prepareResponse.videoId;

        // Upload video
        const uploadResponse = await fetch(prepareResponse.uploadUrl, {
          method: 'PUT',
          body: blob,
          credentials: 'include',
        });

        if (!uploadResponse.ok) {
          throw new Error('Upload failed');
        }

        // Finalize upload
        const finalizeResponse = await apiCall(`/api/videos/${currentVideoId}/finalize`, {
          method: 'POST',
          body: JSON.stringify({
            filename,
            sizeBytes: blob.size,
            durationSeconds: duration,
            expirationType: currentExpirationType,
          }),
        });

        // Show success
        document.getElementById('uploading-section').classList.add('hidden');
        document.getElementById('success-section').classList.remove('hidden');
        document.getElementById('share-link').value = finalizeResponse.shareUrl;

        // Auto-open video in new tab
        window.open(finalizeResponse.shareUrl, '_blank');

      } catch (error) {
        console.error('Error uploading video:', error);
        showToast('Failed to upload video. Please try again.', 'error');
        document.getElementById('uploading-section').classList.add('hidden');
        document.getElementById('setup-section').classList.remove('hidden');
      }
    }

    async function copyLink() {
      const link = document.getElementById('share-link').value;
      const success = await copyToClipboard(link);
      if (success) {
        showToast('Link copied to clipboard!', 'success');
      } else {
        showToast('Failed to copy link', 'error');
      }
    }

    function openVideo() {
      const link = document.getElementById('share-link').value;
      window.open(link, '_blank');
    }

    function downloadVideo() {
      window.location.href = `/api/videos/${currentVideoId}/download`;
    }

    function recordAnother() {
      document.getElementById('success-section').classList.add('hidden');
      document.getElementById('setup-section').classList.remove('hidden');
      recordedChunks = [];
      currentVideoId = null;
    }

    init();
  </script>
</body>
</html>

